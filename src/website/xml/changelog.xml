<appendix xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xml:id="changelog"
          version="5.2">
<info>
<?db filename='changelog.html'?>
<title>Change log</title>
</info>

<revhistory>
<revision>
<revnumber>3.0.0h</revnumber>
<date>2023-07-21</date>
<revdescription>
<para>This is a beta release for version 3.0.0. There are a lot of
changes in this release and many of them impact the public APIs.</para>
<para>Additional small performance improvement in the GLL parser,
small documentation improvements.</para>
</revdescription>
</revision>

<revision>
<revnumber>3.0.0g</revnumber>
<date>2023-07-19</date>
<revdescription>
<para>With an enormous debt of gratitude to 
<link xlink:href="https://mastodon.social/@chriswhocodes">@chriswhocodes</link>,
the performance of the GLL parser is <emphasis>much</emphasis>
improved.</para>
</revdescription>
</revision>

<revision>
<revnumber>3.0.0f</revnumber>
<date>2023-07-18</date>
<revdescription>
<orderedlist>
<listitem><para>Another complete refactor of tree walking. With new
metaphors this time. There are no more tree selectors or
<classname>ForestWalker</classname>s, instead we have
<classname>Arborist</classname>s, either
<classname>org.nineml.coffeegrinder.trees.Lumberjack</classname>s or
<classname>TreeSurgeon</classname>s, armed with
<classname>Axe</classname>s. The idea is that a
<classname>Lumberjack</classname> clears a forest. The lumberjack
walks through the forest sequentially returning all of the applicable
trees. For example, armed with a <classname>SequentialAxe</classname>,
the lumberjack returns all the trees. Armed with a
<classname>PriorityAxe</classname>, the lumberjack returns the highest
priority tree(s). A <classname>TreeSurgeon</classname>, on the other
hand, extracts specific trees with no attempt to be sequential. The
<classname>RandomAxe</classname>, for example, just makes random
choices until a tree is found.</para>
<para>In the best case, where the parse is unambiguous, none of this matters, there is only
one tree in the forest and it doesn’t matter who attempts to get it or how.</para>
</listitem>
<listitem><para>Presented with an infinitely ambiguous forest (one where the graph contains one
or more loops), the lumberjack will return an unbounded number of trees.</para>
</listitem>
<listitem>
<para>When the prefix parsing feature is enabled, it is now possible to resume parsing
with a different parser.</para>
</listitem>
<listitem>
<para>The <classname>ParseTree</classname> has been renamed <classname>GenericTree</classname> and
refactored a bit. The <emphasis>new</emphasis> <classname>ParseTree</classname> class is only
used during the search for a tree.</para>
</listitem>
</orderedlist>
</revdescription>
</revision>

<revision>
<revnumber>3.0.0e</revnumber>
<date>2023-07-12</date>
<revdescription>
<orderedlist>
<listitem><para>Provide tree selectors with all the paths, even those that
are loops. The looping paths are always “other choices”.</para>
</listitem>
<listitem><para>Revised what constitutes “making an ambiguous choice” in the tree selector.
When a tree selector has only a single, non-looping choice, it is still making an
ambiguous choice. The other choice <emphasis>could</emphasis> have been made.
(It remains unambiguous in the priority selector if the priority selector would have
unambiguously made the same choice from all the available choices.)</para>
</listitem>
<listitem><para>Tidied up some tests; removed references to JUnit 4 classes.</para>
</listitem>
</orderedlist>
</revdescription>
</revision>
<revision>
<revnumber>3.0.0d</revnumber>
<date>2023-07-11</date>
<revdescription>
<orderedlist>
<listitem><para>Reworked tree construction. I’ve abandoned the efforts to
return (some of) the infinitely many trees that result when there are loops in the
grammar. Loops are never followed when there are other options.</para>
</listitem>
<listitem><para>Reworked the GLL parser. Removed a whole lot of cruft by using
lambdas directly for the instructions.</para>
</listitem>
<listitem><para>Removed some arbitrary limitations on regular expression matches.
Tested that they work for both the Earley and GLL parsers.</para>
</listitem>
<listitem><para>Removed some dead code, simplified some APIs, tidied up and
improved the JavaDoc.</para>
</listitem>
</orderedlist>
</revdescription>
</revision>
<revision>
<revnumber>3.0.0c</revnumber>
<date>2023-07-09</date>
<revdescription>
<para>Version 3.0.0c fixes a bug where a regular expression pragma would not
successfully parse when the regular expression matched the empty string.</para>
</revdescription>
</revision>
<revision>
<revnumber>3.0.0b</revnumber>
<date>2023-07-09</date>
<revdescription>
<orderedlist>
<listitem><para>Fixed bugs in the “regex” pragma. It’s now supported and tested
in both parsers.</para>
</listitem>
<listitem><para>Improved node and family IDs (they’re now local to the forest).
Extended and improved the <filename>forest2dot.xsl</filename> graph stylesheet.
</para>
</listitem>
</orderedlist>
</revdescription>
</revision>
<revision>
<revnumber>3.0.0a</revnumber>
<date>2023-07-02</date>
<revdescription>
<orderedlist>
<listitem><para>Added an option to analyze the grammar for ambiguity
with Anders Møller’s <link
xlink:href="https://www.brics.dk/grammar/">ambiguity analyzer</link>.
(Note that thie analyzer jar file is included in the repository, but
it isn’t bundled with CoffeeGrinder, you need to add it to your class
path. It is bundled with CoffeePot.) </para></listitem>
<listitem><para>Completely reworked how trees are constructed from the parse forest.
The new code divides tree building and tree selection (choosing among ambiguous alternatives)
into different classes. The result is much, much simpler.
</para></listitem>
<listitem><para>The parser attributes are available to the tree builder. The parser attributes
used by NineML have been renamed to URIs.
</para></listitem>
<listitem><para>The <classname>RuleChoice</classname> class has been removed. Tree selection
can be done directly from the <classname>Family</classname> objects. A unique ID has been added
to each family.
</para></listitem>
<listitem><para>The parser supports a priority attribute for guiding
the selection between ambiguous alternatives. If a particular family
does not have an assigned priority, it’s priority can be computed as
either the highest priority of any of its descendants or the sum of
the priorities of its descendants.
</para></listitem>
<listitem><para>Priorities are now integers, not floats. The parser option “priority style” controls
whether computed priorities are maximum values or sums.
</para></listitem>
<listitem><para>Priorities (and other parser attributes) may cause new
nonterminals to be created when the parser is constructed. The <classname>NonterminalSymbol</classname>
field <varname>symbolName</varname> can be used to distingiush between them (as can
the symbol ID, of course). The <methodname>getName()</methodname> method always returns the canonical name.
</para></listitem>
<listitem><para>The parse forest no longer exposes multiple root nodes. They can only exist
before the forest is pruned.
</para></listitem>
</orderedlist>

<para>The default “sequential” tree selector will choose every node
and ever edge at least once. For graphs without loops, this matches
the number of parses reported. Tree construction from graphs that
contain loops is challenging. The total number of parses reported does
not take loops into consideration. (Graphs with loops have an infinite
number of parse trees.) The tree selector tries to follow all of the paths once, but
it may fail for pernicously looped graphs:</para>

<figure>
<title>A perniciously looped graph</title>
<mediaobject>
<imageobject>
  <imagedata fileref="images/pernicious.svg"/>
</imageobject>
<caption><para>A graph where X⇔Y, X⇔Z, Y⇔Z, X→’x’|ε, Y→’x’|ε, Z→’x’|ε, </para></caption>
</mediaobject>
</figure>

<para>It will get many, but not necessarily all of the possible paths. The priority tree
selector will always choose the path with the highest priority (if there is one). If all choices
are made by a uniquely highest priority in each case, this fact is recorded. CoffeeFilter can use this
when calculating whether or not to mark a parse as ambiguous.</para>
</revdescription>
</revision>

<revision>
<revnumber>2.2.1</revnumber>
<date>2023-05-17</date>
<revdescription>
<para>Fixed a small bug in the presentation of alternative parses when
there is ambiguity. Nonterminal symbols in the alternative choices did
not necessarily have the correct attributes.</para>
</revdescription>
</revision>
<revision>
<revnumber>2.2.0</revnumber>
<date>2023-05-06</date>
<revdescription>
<itemizedlist>
<listitem>
<para>CoffeeGrinder now carefully distinguishes between nonterminals
with different attributes. This introduces new nonterminals into
the grammar. These can be examined by calling
<methodname>resolveDuplicates</methodname> on the
<classname>SourceGrammar</classname>.</para>
<para>If, for example, you have two instances of a nonterminal
“B” in the grammar, where one has a mark attribute of “^” and the
other a mark attribute of “@”, after resolving duplicates there
will be two nonterminals in the grammar, “B” and “B₁”. They will
match the same inputs, but is now possible to distinguish between
them in the parse forest.</para>
<para>One particular use for this feature is the priority attribute
supported by CoffeeFilter. This attribute allows the grammar author
to associate priorities with nonterminals in ambiguous grammars to
guide the parse.</para>
</listitem>
<listitem>
<para>All of the infrastructure associated with “pruning” nonterminals
that lead to ε has been removed. (It hasn’t actually be used for at
least a couple of releases.)
</para>
</listitem>
</itemizedlist>
</revdescription>

</revision>
<revision>
  <revnumber>2.1.0</revnumber>
  <date>2023-04-23</date>
  <revremark>Updated the API for choosing among alternatives to supply the immediate context.</revremark>
</revision>
<revision>
  <revnumber>2.0.0</revnumber>
  <date>2023-04-10</date>
  <revremark>Making the 2.x code base the current release.</revremark>
</revision>
<revision>
  <revnumber>1.99.1</revnumber>
  <date>2022-06-17</date>
  <revremark>Second pre-release with GLL support; substantial refactoring of the internals
and a new API for getting trees from the parse forest.
</revremark>
</revision>
<revision>
  <revnumber>1.99.0</revnumber>
  <date>2022-06-08</date>
  <revremark>First pre-release that included GLL parser support. Updated to the
Invisible XML 1.0 grammar.</revremark>
</revision>
<revision>
  <revnumber>1.1.0</revnumber>
  <date>2022-04-16</date>
  <revremark>Internal changes to support the 15 April 2022 Invisible XML “insertions” feature, version 1.1.0</revremark>
</revision>
<revision>
  <revnumber>1.0.0</revnumber>
  <date>2022-03-20</date>
  <revremark>Initial release, version 1.0.0</revremark>
</revision>
</revhistory>

</appendix>
